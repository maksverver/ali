# NOTE: this sample is outdated!

# All text after a # character (outside a string) is a comment

# Central to the interpreter is the concept of a sentence, which is a
# sequence of words that is parsed into several components. Each word
# starts with a letter and may contain only letters and digits.
#
# Identifiers are sequences of letters, digits and underscores, which may not
# start with a digit.
#
# There are three types of sentence components (which may actually
# contain several words):
#   verbs
#   entities
#   prepositions
# These are distinguised by the fact that every sentence is formed in one of
# the following ways:
#   <verb>                          (e.g. QUIT)
#   <verb> <entity>                 (e.g. TAKE SPOON)
#   <verb> <entity> <preposition> <entity>  (e.g. OPEN DOOR WITH KEY)
#
# Entities are special because they can have variables associated with them,
# called properties. There are also variables, not associated with any entity,
# call global variables. All variables are scalar; they can be defined and
# undefined.
#
# Words can refered to literally or through a symbol that is specified on
# declaration. All words have an internal reference 
#
# The following literal values are recognized:
#   - integers; e.g. 0, 123, -12, 123 (without leading zeroes or plus sign ) 
#   - strings: e.g. "Foo bar"
#   - symbols: e.g. :true, :red, :no
#   - entity references: e.g. [BEDROOM]
#
# Equality is strict (e.g. both types and values must match)
#
# Variables associated with entities can be referenced with a dot:
#   [BEDROOM].visited = :no
#   :bedroom.seen = :yes
#

# Every declaration starts with a dot-directive:
#   verb       (declare a verb)
#   prepostion (declare a preposition)
#   entity     (declare an entity)
#   function   (declare a function)
#   command    (declare a command)
# The file is a series of declarations of words, functions and commands.
# Words must be declared before they can be used.


# Declare verbs:
verb QUIT (GAME); EXIT (GAME).
verb GO (TO).
verb LOOK (AROUND | AT).

# Declare entities:
entity PIRATE | (CAPTAIN) JACK (SPARROW).
entity :bedroom (MY) BEDROOM.
entity (LARGE) KEYCHAIN.
entity SPELLBOOK | BOOK (WITH (NECROMANCY) SPELLS)

# Declare
preposition WITH | USING

# Declare functions

function initialize {
    # A function called initialize is called when the script is started.
    set @location [BEDROOM];
}

# A function has named arguments and can introduce local variables.
# Arguments can be assigned, but this only has effect in local scope.
# A function may return a value.
function foo $arg1 $arg2 $arg3 {
    set $tmp $arg1;
    if $args2 <> $args3 { return; }
    return $tmp;    
}

# Declare commands:

command [GO TO] :room {
    # Entity reference: [descr]
    if @location = [BEDROOM] {
        write("You're already [i]there[/i].")
    }

    set @location BEDROOM;

    if [BEDROOM]@locked
    {
        write("Sorry, it's locked.")
    }
    else
    {
        set @location [BEDROOM];
        # unset @variable
    }
}

command LOOK AROUND {
    if @location = [BEDROOM] {
        write("[b]In your bedroom[/b][,]"
        "This is an example. String are concatenated and paragraphs are "
        "reformatted to fit the console width.[;]"
        "How to format paragraphs?")
    }
}

command LOOK $item {
    if ($item.description) {
        write($item.description)
    }
}

command EXIT {
    # Call an interpreter function
    i_exit();
}

# String formatting:
# [b]bold/bright[/b]
# [in]indent[/in]
# [,] row break
# [;] paragraph break
# [ ] non-breaking space
# \[ literal [
# \" literal "
# \' literal '


# Expression syntax (example):
# (a <> 3 or b) and (b = 2 or not c)
